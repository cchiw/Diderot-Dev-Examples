#version 1.0
/* ==========================================
## fs3d-scl.diderot: function sampler, 3D scalar synthetic fields

`fs3d-scl.diderot` is based on [`fs2d-scl.diderot`](../fs2d); some
copy-and-pasting was involved.  Like that program, the utility of this
program is to generate datasets for other Diderot programs to work on.
This same directory has a `fs3d-vec.diderot` for generating vector
fields, and possibly other programs; the documentation below is for
`fs3d-scl.diderot` though the other programs will have very similar
structure and usage.

This programs generates synthetic scalar 3D data on regular grids that
are located and oriented in world space.  The input arguments here
make it easy to sample the same underlying function on different
grids.  Grid orientation is specified by the angle and axis of
rotation.

The `-which` option will determine which function is sampled; look for
`(0 == which)` in the code to see the start of the function
definitions, this includes 3D functions used to make datasets for
[some](http://people.cs.uchicago.edu/~glk/pubs/#VIS-2003)
[previous](http://people.cs.uchicago.edu/~glk/pubs/#VIS-2009)
[papers](http://people.cs.uchicago.edu/~glk/pubs/#VIS-2014).

This program is unusual in that its printed output needs to be captured
in order to have a NRRD header that records the orientation of the
sampling grid, so using the program involves redirection.  To
get a self-contained parab.nrrd containing a parabola function

	./fs3d-scl -which 3 | unu save -f nrrd -o parab.nrrd
	rm out.nrrd

Note that like in [`fs2d-scl.diderot`](../fs2d), the NRRD header
generated by this program assumes:

1. This program was not compiled with `--double`
2. The program is running on a little-endian machine.

========================================== */
input int which ("which function to sample (from 0 to 14)");
input int sz0 ("# samples on fastest axis") = 52;
input int sz1 ("# samples on medium axis") = 51;
input int sz2 ("# samples on slowest axis") = 50;
input real width ("width of edge of cube region sampled") = 4;
input vec3 axis ("axis (non-normalized) of rotation of sampling grid") = [1,1,1];
input real angle ("angle (in degrees) of rotation of sampling grid") = 0;
input vec3 shear ("amount of shear between three axes") = [0,0,0];
input vec3 off ("translation offset, in index space, from origin-centered grid") = [0,0,0];
input vec3 waxis ("axis (non-normalized) of rotation of world space") = [1,-1,1];
input real wangle ("angle (in degrees) of rotation of world space") = 0;
input vec4 parm ("parameters that functions may use") = [0,0,0,0];

/* Create rotation matrix by conversion from the given quaternion,
   which aren't currently natively supported in Diderot.  Note how a
   function may be defined by equality with a single expression */
function tensor[3,3] q2rot(vec4 qq) = [
   [ qq[0]*qq[0] + qq[1]*qq[1] - qq[2]*qq[2] - qq[3]*qq[3],
     2*(qq[1]*qq[2] - qq[0]*qq[3]),
     2*(qq[1]*qq[3] + qq[0]*qq[2]) ],
   [ 2*(qq[1]*qq[2] + qq[0]*qq[3]),
     qq[0]*qq[0] - qq[1]*qq[1] + qq[2]*qq[2] - qq[3]*qq[3],
     2*(qq[2]*qq[3] - qq[0]*qq[1]) ],
   [ 2*(qq[1]*qq[3] - qq[0]*qq[2]),
     2*(qq[2]*qq[3] + qq[0]*qq[1]),
     qq[0]*qq[0] - qq[1]*qq[1] - qq[2]*qq[2] + qq[3]*qq[3] ]
];

real tht = angle*π/180;
// unit-length axis of rotation scaled by sin(tht/2)
vec3 snax = sin(tht/2)*normalize(axis);
// quaternion representing sampling grid rotation
vec4 qq = [cos(tht/2), snax[0], snax[1], snax[2]];
tensor[3,3] rot = q2rot(qq);
// repeat of above for world-coordinates
real wtht = wangle*π/180;
vec3 wsnax = sin(wtht/2)*normalize(waxis);
tensor[3,3] wrot = q2rot([cos(wtht/2), wsnax[0], wsnax[1], wsnax[2]]);

// per axis inter-sample edge vectors
vec3 spc = width*[1.0/(sz0-1), 1.0/(sz1-1), 1.0/(sz2-1)];
vec3 edge0 = rot•[spc[0], 0, 0];
vec3 edir1 = rot•[0, spc[1], 0];
vec3 edir2 = rot•[0, 0, spc[2]];
// push axis1 torwards axis0 by shear[0]
vec3 edge1 = edir1 + spc[1]*shear[0]*normalize(edge0);
// push axis2 torwards axis0 by shear[1], and axis1 by shear[2]
vec3 edge2 = edir2 + spc[2]*(shear[1]*normalize(edge0) + shear[2]*normalize(edir1));
// offset in world space
vec3 offws = [off[0]*spc[0], off[1]*spc[1], off[2]*spc[2]];
// location of first sample point
vec3 orig = -(edge0*(sz0-1) + edge1*(sz1-1) + edge2*(sz2-1))/2 + offws;

// univariate normal distribution
function real gauss(real stdv, real x) =
   exp(-(x*x)/(2*stdv^2))/(stdv*sqrt(2*π)); // have some π

// distance inside sphere of radius r
function real ball(real r, vec3 pos) = max(0, r - |pos|);

/*
// radius R cone pointing along positive x
function real cone(real R, vec3 pos) {
   real x = pos[0];
   real y = pos[1];
   real z = pos[2];
   real ret = max(0, R - (sqrt(y^2 + z^2) + x/2));
   ret *= 1 if (x > 0) else 0;
   return ret;
}
*/

// width R pyramid pointing along positive x
function real pyra(real R, vec3 pos) {
   real x = pos[0];
   real y = pos[1];
   real z = pos[2];
   real ret = max(0, R - (max(|y|,|z|) + x/2));
   ret *= 1 if (x > 0) else 0;
   return ret;
}

// trapezoid function at b in [a,c], with ramp R
function real trpz(real R, real a, real b, real c, real scl) {
   real ww = (b-a)/(c-a);
   real rr = R + 0.000001;
   // Note the use of Python syntax for conditional expressions
   return (0 if ww < -rr else
           scl*(1 + ww/rr) if ww < 0 else
           lerp(scl, 1, ww) if ww < 1 else
           1 - (ww-1)/rr if ww < 1+rr else 0);
}

function real func(vec3 pos0) {
   vec3 pos = wrot•pos0;
   real x = pos[0];
   real y = pos[1];
   real z = pos[2];
   real ret = 0;
   real size = 0.25;
    if (0 == which) {
        real shiftx = -1.5;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (1 == which) {
        real shiftx = -1.0;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (2 == which) {
        real shiftx = -0.5;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (3 == which) {
        real shiftx = 0.0;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (4 == which) {
        real shiftx = 0.5;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (5 == which) {
        real shiftx = 1.0;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
    } else if (6 == which) {
        real shiftx = 1.5;
        real shifty = 0.0;
        real shiftz = 0.0;
        ret = size - (((shiftx-x)*(shiftx-x))+((shifty-y)*(shifty-y))+((shiftz-z)*(shiftz-z)));
       } else if (7 == which) {
            ret = x;
    } else if (8 == which) {
        ret = x*x;
    } else if (9 == which) {
        ret = y;
    } else if (10 == which) {
        ret = x - 1.0;
    } else if (11 == which) {
        ret = z +y- 1.0;
} else if (12 == which) {
ret = x +y- 1.0;

} else if (13 == which) {
ret = z +x- 1.0;

   } else {
      // update "input int which" annotation above as cases are added
      print("Sorry, no function defined for which = ", which, "\n");
   }
   return ret;
}

strand sample(int idx0, int idx1, int idx2) {
   output real out = 0.0;
   update {
      /* see comment in ../fs2d/fs2d-scl.diderot about the need for these
         conditionals around the print statements */
      if (0 == idx0 && 0 == idx1 && 0 == idx2) {
         print("NRRD0004\n");
         print("# Complete NRRD file format specification at:\n");
         print("# http://teem.sourceforge.net/nrrd/format.html\n");
         /* NOTE: this assumes we haven't been compiled with --double,
            and there isn't currently a way for the program to learn this
            (which in our experience has not been a problem) */
         print("type: float\n");
         print("dimension: 3\n");
         print("sizes: ", sz0, " ", sz1, " ", sz2, "\n");
         print("kinds: space space space\n");
         print("centers: cell cell cell\n");
         // NOTE: this assumes machine endianness
         print("endian: little\n");
         print("encoding: raw\n");
         print("space dimension: 3\n");
         print("space directions: (", edge0[0], ",", edge0[1], ",", edge0[2],
                               ") (", edge1[0], ",", edge1[1], ",", edge1[2],
                               ") (", edge2[0], ",", edge2[1], ",", edge2[2], ")\n");
         print("space origin: (", orig[0], ",", orig[1], ",", orig[2], ")\n");
         print("data file: out.nrrd\n");
         print("byte skip: -1\n");
      }
      out = func(orig + idx0*edge0 + idx1*edge1 + idx2*edge2);
      stabilize;
   }
}
initially [ sample(idx0, idx1, idx2)
            | idx2 in 0..(sz2-1),  // slowest axis
              idx1 in 0..(sz1-1),  // medium axis
              idx0 in 0..(sz0-1)]; // fastest axis
